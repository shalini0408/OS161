diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..48edd87
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,9 @@
+{
+    "files.associations": {
+        "test.h": "c",
+        "types.h": "c",
+        "stoplight_framework.h": "c",
+        "thread.h": "c",
+        "tuple": "c"
+    }
+}
\ No newline at end of file
diff --git a/asst1-part1/code-reading.txt b/asst1-part1/code-reading.txt
new file mode 100644
index 0000000..32757b5
--- /dev/null
+++ b/asst1-part1/code-reading.txt
@@ -0,0 +1,67 @@
+PA1, Part 1 --  Code Reading Questions 
+
+1. What happens to a thread when it exits (i.e., calls thread_exit())? What about when it sleeps? 
+
+When a thread called thread_exit(), it causes the current thread to exit. When a thread exits the parts of the thread we don't actually 
+need to get cleaned up right away. The rest has to wait until thread_destroy gets called from exorcise(). When a thread sleeps, it yields 
+(give up the CPU) to the next runnable thread. It then goes to sleep until wakeup() is called on the same address. 
+
+
+2. What function(s) handle(s) a context switch? 
+
+md_switch(struct pcb *old, struct pcb *nu) – machine dependent context switch 
+mi_switch(threadstate_t, nextstate) – high level, machine-independent context switch 
+
+
+3. What does it mean for a thread to be in each of the possible thread states? 
+
+S_RUN → a thread that is currently running  
+S_READY → a thread that is ready to run and is in the ready queue 
+S_SLEEP → a sleeping thread 
+S_ZOMB → a zombie thread whose parent terminated without calling the results of this child 
+
+
+4. What does it mean to turn interrupts off? How is this accomplished? Why is it important to turn off interrupts in the thread subsystem code? 
+
+When interrupts are turned off, when an interrupt is sent, it does not trigger the handler. Interrupts are turned off by setting the spl level 
+to splhigh(). Turning off the interrupts is important in the thread subsystem code because it will prevent important tasks from being interrupted 
+mid-execution (such as context switching, printing the run queue, updating the thread counter, forking and thread termination). If they were 
+interrupted it could cause race conditions, loss/corruption of data, inconsistent state etc. 
+
+
+5. What happens when a thread wakes up another thread? How does a sleeping thread get to run again? 
+
+When a thread wakes up another thread, the thread that was sleeping will become runnable again and go back into the ready queue. 
+
+
+6. What function is responsible for choosing the next thread to run?
+
+struct thread *scheduler(void) is responsible for the next thread to run.
+
+
+7. How does that function pick the next thread?
+
+The scheduler is a round-robin run queue. When the current thread times out, it moves to the end of the ready queue (if it didn’t terminate). 
+The scheduler picks the next thread in the queue as the next thread to run. No prioritization. The scheduler() calls the cpu_idle() recursively 
+until the run queue is empty.
+
+
+8. What role does the hardware timer play in scheduling? What hardware independent function is called on a timer interrupt? 
+
+The function hardclock() is called on a timer interrupt. At the end of the function, thread_yield() is called which causes a context switch. 
+
+
+9. Describe how thread_sleep() and thread_wakeup() are used to implement semaphores. What is the purpose of the argument passed to thread_sleep()? 
+
+When a semaphore calls wait(), it checks the value and tries to acquire the semaphore. If the value is 0, the thread that called wait will be put 
+to sleep using thread_sleep(). When another thread calls V() (same as signal()) to indicate they are releasing the resource, thread_wakeup() will 
+be called on the sleeping thread so it can use the resource and continue executing. The argument passed into thread_sleep() is the address of the 
+thread that is going to sleep. When thread_wakeup() is called on the same address, that same thread will wake up. The address is used as the 
+identifier. 
+
+
+10. Why does the lock API in OS/161 provide lock_do_i_hold(), but not lock_get_holder()?
+
+The function lock_do_i_hold() returns 0 if the calling thread does not hold the lock and 1 if it does. Only the holding thread can release the 
+lock. If there was a lock_get_holder() function, it would return which thread is holding the lock. However, this information would be useless 
+because only the holding thread can release the lock. 
diff --git a/asst1-part1/progress-report.txt b/asst1-part1/progress-report.txt
new file mode 100644
index 0000000..d349fcb
--- /dev/null
+++ b/asst1-part1/progress-report.txt
@@ -0,0 +1,47 @@
+PA1, Part 1 -- Progress Report 
+
+Kaitlin O’Leary G01372290
+Shalini Maknoor G01503797
+
+
+Lock Design and Implementation 
+
+- Took the semaphores code and used it as a model for the lock implementation. 
+- We had four functions for the lock implementation. Each partner implemented two functions. 
+- We then tested the complete implementation together using Zeus. 
+
+
+Problems Encountered 
+
+- We had many syntax errors as we did our first implementation. 
+- We continuously modified our logic. 
+- When we tested in Zeus, we encountered a kernel hang. Together, we commented out each function and methodically tested each one. We did not 
+initialize the flag value in the lock creation function and we accidentally set the lock flag to 0 in lock_acquire() instead of 1. 
+- After fixing the issues above, we tested with the menu and got the correct implementation (see screenshot below). 
+
+
+Correct lock implementation shows: 
+
+sy2
+Starting lock test...
+Lock test done.
+Operation took 2.988475840 seconds 
+
+At this point, we have the project files set up, the lock implementation complete. We are now about to start the design and implementation of 
+the traffic management problem. 
+
+
+Traffic Management Problem Findings 
+
+- Our critical section will be the intersection. The critical section will be different parts of the intersection depending on what route 
+the vehicle is taking.  
+- Use a priority queue (implemented as a dynamic max heap) for each route so that cars will be prioritized over trucks and cars that arrive 
+first will enter the intersection first (FIFO). 
+- When turning right, a vehicle only needs to pass through one intersection. The thread (that is the vehicle) will try to acquire the lock for 
+the corner of the intersection they go through. They will either execute the turn or sleep and keep checking if the lock is free. 
+- When turning left, there are two parts of the intersection the vehicle needs to go through. The thread will check the first part of the 
+intersection first. If it is free, it will acquire that lock. If not it will sleep, and then keep checking. Once it has the first lock, it will 
+pass through the first part of the intersection. It will then try to acquire the second lock. If it is free, it will release the first lock and 
+acquire the second lock and execute the remainder of the turn. If it is not free, it will sleep and check until it can acquire the lock.
+- We are concerned this solution might cause starvation among the cars. If a car is waiting for the second lock to turn left, no other cars can 
+use the first lock. This may cause excessive bounded waiting. 
diff --git a/kern/asst1/asst1.code-workspace b/kern/asst1/asst1.code-workspace
new file mode 100644
index 0000000..437ac53
--- /dev/null
+++ b/kern/asst1/asst1.code-workspace
@@ -0,0 +1,11 @@
+{
+	"folders": [
+		{
+			"path": "."
+		},
+		{
+			"path": ".."
+		}
+	],
+	"settings": {}
+}
\ No newline at end of file
diff --git a/kern/asst1/design.txt b/kern/asst1/design.txt
new file mode 100644
index 0000000..85fdcaa
--- /dev/null
+++ b/kern/asst1/design.txt
@@ -0,0 +1,115 @@
+Kaitlin O'Leary 
+Shalini Maknoor
+
+PA1, Part 2 -- Design Document
+
+1. High-level overview of the solution
+
+Our solution implements a priority queue for each route, a priority sleeping queue for each route, as well as a counter that keeps track of 
+finished vehicles. When a vehicle approaches, it is added to the priority queue that corresponds to its route. A lock is used to add the vehicle 
+to the queue. The vehicle then checks if it is at the head of the queue. If it is, it executes its turn. If it isn’t, it adds itself to the 
+sleeping queue for its route and goes to sleep. It will be woken up by a thread when it is the next vehicle in the queue (i.e. when it is the 
+head of the queue). After waking, it will dequeue from the sleeping queue and execute its turn. After turning, it will remove itself from the 
+priority queue for its route and wake the thread that is now at the head of the queue. Last, it will increment vehicle_count, which keeps track 
+of the number of vehicles that are finished. Lock are used throughout to protect the priority queue, sleeping queue, and vehicle_count. After all 
+vehicles have finished (i.e. when vehicle_count is equal to vehicles_finished are equal), finish() is called. 
+
+vehicle_thread():
+When a vehicle approaches a particular route, it is added to the priority queue for that route. This ensures that cars will always be prioritized 
+over trucks. A lock is used to ensure only one thread is editing the priority queue at a time. If the thread is next to enter the intersection 
+(i.e. it is the head of the queue), it executes its turn. If the vehicle is not next (i.e. it is not the head of the queue), the vehicle is added 
+to the sleep queue (a different lock is used to protect the sleeping queue). After sleeping, it dequeues itself from the sleeping queue 
+(again, using a lock), executes its turn and leaves the intersection. It then wakes up the vehicle that is next in the priority queue 
+(i.e. the one at the head of the queue). Lastly, vehicle_count, that keeps track of the number of vehicles that have finished, is incremented. 
+
+turn_left()
+Before turning, the vehicle acquires the two locks that are on its route (AB and BC for route A, BC and CA for route B, and AB and CA for route C).
+It then enters the intersection and goes through the first section, transfers into the next section, and removes itself from the priority queue 
+(using a lock to ensure only one thread edits the queue at once). It then releases the first section’s lock, leaves the intersection, and then 
+releases the second section’s lock. This is to help prevent deadlock. 
+
+turn_right() 
+Before turning, the vehicle acquires the lock on its route (AB for route A, BC for route B, and CA for route C). It then enters the intersection. 
+The vehicle is removed from the priority queue (using a lock to ensure only one thread edits the queue at a time), leaves the intersection, and 
+releases the lock. 
+
+stoplight_driver():
+In the driver, all the locks necessary are initialized. Then all the vehicle threads are created. A while loop is used to wait until all vehicles 
+are finished. Finish is then called and all locks are destroyed. 
+
+
+2. How many locks you used in your program and for what purpose(s)
+
+We used 10 locks in our implementation: 
+
+vehicle_count_lock: 
+This lock protects the global variable called vehicle_count that keeps track of the number of finished vehicles. The driver uses this variable to 
+determine if all vehicles have finished. The lock is used when vehicle_count is incremented in the vehicle_thread() function and when the number 
+of finished vehicles is checked in the stoplight_driver() function.
+
+intersection_AB_lock: 
+This lock protects the AB section of the intersection. It is locked whenever a vehicle enters this section and unlocked when it leaves. 
+
+intersection_BC_lock: 
+This lock protects the BC section of the intersection. It is locked whenever a vehicle enters this section and unlocked when it leaves. 
+
+intersection_CA_lock: 
+This lock protects the CA section of the intersection. It is locked whenever a vehicle enters this section and unlocked when it leaves. 
+
+routeA_LL_Lock: 
+This lock protects the linked list that is the priority queue for route A. This lock is used whenever a vehicle is added during approach(), 
+removed during leave(), or whenever the queue or head of the queue is checked. 
+
+routeB_LL_Lock: 
+This lock protects the linked list that is the priority queue for route B. This lock is used whenever a vehicle is added during approach(), 
+removed during leave(), or whenever the queue or head of the queue is checked. 
+
+routeC_LL_Lock: 
+This lock protects the linked list that is the priority queue for route C. This lock is used whenever a vehicle is added during approach(), 
+removed during leave(), or whenever the queue or head of the queue is checked. 
+
+sleep_A_lock: 
+This lock protects the linked list that is the sleeping queue for route A. It is used whenever a vehicle is added before it sleeps and when it is 
+removed after it is woken up. It is also used when this queue is checked. 
+
+sleep_B_lock: 
+This lock protects the linked list that is the sleeping queue for route B. It is used whenever a vehicle is added before it sleeps and when it is 
+removed after it is woken up. It is also used when this queue is checked. 
+
+sleep_C_lock: 
+This lock protects the linked list that is the sleeping queue for route C. It is used whenever a vehicle is added before it sleeps and when it is 
+removed after it is woken up. It is also used when this queue is checked. 
+
+
+3. How you achieved the objective of giving high-priority to cars (compared to trucks); explain what type of data structures and synchronization 
+primitives you used for that purpose
+
+For each route, we have a linked list that functions as a priority queue. When a car approaches, it is added to the priority queue (using a lock 
+to ensure only one thread edits the queue at a time). If there are no vehicles in the queue, it is added as the head. If there are only cars in 
+the queue, it is added at the end of the list. If there are trucks in the queue, the car is inserted right before the first truck in the list 
+(so it is after all the cars and before the trucks). This means the head of the queue is always the vehicle that should enter the intersection on 
+that route next. 
+
+When a truck approaches, it is added to the priority queue (using a lock to ensure only one thread edits the queue at a time). If there are no 
+vehicles in the queue, it is added as the head. If there are any vehicles (trucks or cars or a combination), it is added to the end of the queue. 
+This is because trucks have a lower priority than cars. 
+
+For each of these linked lists, we have a lock that protects it so only one thread is editing the linked list at a time. The order of the list 
+ensures that cars that have approached will go before trucks and vehicles of the same type will go in the order in which they approached. 
+
+
+4. Specific rules you implemented to admit, suspend, and wake up a vehicle thread, approaching the intersection from a specific lane: you may want to list separate cases you considered.
+
+Admitting a vehicle: 
+When a vehicle approaches an intersection, it is inserted into the linked list that functions as the priority queue for that route (using a lock 
+to ensure only one thread can edit the queue at a time). When that vehicle is at the head of the queue, it is the vehicle that will enter next on 
+that route. This ensures that cars are prioritized over trucks and vehicles of the same type enter in the order they approached. 
+
+Suspending/Sleeping a vehicle: 
+After a vehicle approaches the intersection, it checks if it is the head of the priority queue. If it is, it enters the intersection. If it isn’t, 
+it enqueues itself to the sleeping queue for that route (using a lock to ensure only one thread can edit the queue at a time). Interrupts are then 
+disabled and the thread goes to sleep. When the thread wakes up, it dequeues itself from the sleeping queue (using a lock to ensure only one 
+thread can edit the queue at a time) and re-enables interrupts. Interrupts are disabled so that sleeping and dequeuing are atomic. 
+
+Waking up a vehicle:
+After a vehicle finishes turning and leaves the intersection, it wakes up the next thread, which is the thread at the head of the priority queue. 
diff --git a/kern/asst1/exercises.txt b/kern/asst1/exercises.txt
new file mode 100644
index 0000000..5a2f0c5
--- /dev/null
+++ b/kern/asst1/exercises.txt
@@ -0,0 +1,25 @@
+Kaitlin O'Leary
+Shalini Maknoor
+
+PA1, Part 2 -- Exercise Questions 
+
+1. Assume that the residents of Podunk are exceptional and follow the old (and widely ignored) convention that whoever arrives at the intersection 
+first proceeds first. Using the language of synchronization primitives describe the way this intersection is controlled. In what ways is this 
+method suboptimal?
+
+In this model of the intersection, only one vehicle is in the intersection at a time. This means the entire intersection is the critical section 
+that is protected by only one lock. This allows only one vehicle into the intersection at a time. The next vehicle cannot go until the first 
+vehicle leaves and unlocks the intersection. Additionally, there is no concurrency in this model. For example, if a car from Route A approaches 
+first and is turning right, no other car can enter the intersection, even if it wouldn’t crash into the car turning right (if it was turning right 
+from route B, for example). Lastly, there is a large amount of waiting because there is only one lock for the entire intersection. 
+
+2. Now, assume that the residents of Podunk are like most people and do not follow the convention described above. In what one instance can this 
+three-way-stop intersection produce a deadlock? (It will be helpful to think of this in terms of the model we are using instead of trying to 
+visualize an actual intersection).
+
+An example that causes deadlock is when a vehicle from each route is trying to turn left all at the same time. The vehicle from route A will 
+acquire lock AB, the vehicle from route B will acquire BC, and the vehicle from route C will acquire lock CA. Because each vehicle holds a lock, 
+they will be eternally waiting for the other lock that is already held by another vehicle. None of them can ever acquire the second lock, so no 
+vehicle will ever complete the turn. 
+
+	
diff --git a/kern/asst1/stoplight.c b/kern/asst1/stoplight.c
index 073ed3c..6ee8794 100644
--- a/kern/asst1/stoplight.c
+++ b/kern/asst1/stoplight.c
@@ -10,7 +10,6 @@
  * Includes
  *
  */
-
 #include "stoplight_framework.h"
 
 #include <types.h>
@@ -19,6 +18,49 @@
 #include <thread.h>
 
 
+#include <synch.h> 
+#include <machine/spl.h>
+
+/*GLOBAL VARIABLES*/
+//intersection locks 
+struct lock *intersection_AB_Lock; 
+struct lock *intersection_BC_Lock; 
+struct lock *intersection_CA_Lock ; 
+
+//Route LL locks 
+struct lock *routeA_LL_Lock ; 
+struct lock *routeB_LL_Lock; 
+struct lock *routeC_LL_Lock; 
+
+//node struct 
+struct Node {
+	long unsigned int vehicle; 
+	struct Node* next; 
+};
+
+//Route LL head nodes 
+struct Node *head_A = NULL; 
+struct Node *head_B = NULL; 
+struct Node *head_C = NULL; 
+
+	/* data */
+int vehicles_finished = 0;
+struct lock *vehicle_count_lock;
+
+//sleeping queue LL head nodes 
+struct Node *sleep_head_A = NULL; 
+struct Node *sleep_head_B = NULL; 
+struct Node *sleep_head_C = NULL; 
+
+//sleeping queue locks 
+struct lock *sleep_A_lock; 
+struct lock *sleep_B_lock; 
+struct lock *sleep_C_lock; 
+
+//sleeping queue function headers 
+void enqueue(struct Node **sleep_head, unsigned long int vehiclenumber);
+void dequeue(unsigned long int vehiclenumber, struct Node **sleep_head);
+
 /*
  *
  * Function Definitions
@@ -40,18 +82,110 @@
  *      Write and comment this function.
  */
 
-static
 void
 turn_left(unsigned long vehiclenumber)
 {
-	/*
-	 * Avoid unused variable warnings.
-	 */
+	//get vehicle route 
+	int route = get_vehicle_route(vehiclenumber);
 
-	(void) vehiclenumber;
+	//Intersection AB - BC
+	if(route == 0){
+		//if route head is null, return 
+		if(head_A == NULL){
+			return;
+		}
+		//acquire AB and BC locks 
+		lock_acquire(intersection_AB_Lock);
+		lock_acquire(intersection_BC_Lock);
+
+		//enter intersection 
+		enter(vehiclenumber,0);
+
+		//transfer intersections 
+		transfer(vehiclenumber,0,1);
+
+
+		//remvoe vehicle from head of queue and free 
+		if (head_A->vehicle == vehiclenumber) {
+			struct Node *temp = head_A;
+			head_A = temp->next;
+			kfree(temp);
+		}
+
+		//release AB lock
+		lock_release(intersection_AB_Lock);
+		//leave intersection 
+		leave(vehiclenumber,1);
+		//relaese BC lock 
+		lock_release(intersection_BC_Lock);
+	}
+
+	// Intersection BC - CA
+	if(route == 1){
+
+		//if head is null return 
+		if(head_B == NULL){
+			return;
+		}
+		
+		//aquire BC and CA lock 
+		lock_acquire(intersection_BC_Lock);
+		lock_acquire(intersection_CA_Lock);
+
+		//enter intersection 
+		enter(vehiclenumber,1);
+		//transfer to new part of the intersection 
+		transfer(vehiclenumber,1,2);
+
+		//remove vehicle from head and free 
+		if (head_B->vehicle == vehiclenumber){
+			struct Node *temp = head_B;
+			head_B = temp->next;
+			kfree(temp);
+		}
+
+		//release BC lock 
+		lock_release(intersection_BC_Lock);
+		//leave intersection 
+		leave(vehiclenumber,2);
+		//release CA lock 
+		lock_release(intersection_CA_Lock);
+	}
+
+	//intersection CA-AB 
+	if(route == 2){
+		//if head is null, return 
+		if(head_C == NULL){
+			return;
+		}
+
+		//acquire CA and AB locks 
+		lock_acquire(intersection_CA_Lock);
+		lock_acquire(intersection_AB_Lock);
+
+		//enter intersection CA 
+		enter(vehiclenumber,2);
+		//transfer to AB
+		transfer(vehiclenumber,2,0);
+
+		//remove vehicle from head of list and free 
+		if (head_C->vehicle == vehiclenumber){
+			struct Node *temp = head_C;
+			head_C = temp->next;
+			kfree(temp);
+		}
+
+		//release CA lock 
+		lock_release(intersection_CA_Lock);
+		//leave AB intersection 
+		leave(vehiclenumber,0);
+		//release AB lock 
+		lock_release(intersection_AB_Lock);
+	}
 }
 
 
+
 /*
  * turn_right()
  *
@@ -75,7 +209,90 @@ turn_right(unsigned long vehiclenumber)
 	 * Avoid unused variable warnings.
 	 */
 
-	(void) vehiclenumber;
+	//get route 
+	int route = get_vehicle_route(vehiclenumber); 
+
+	//if route is A 
+	if (route == 0){
+
+		//if no vehicles in route, return 
+		if (head_A == NULL) {
+			return; // return early if no vehicle exists
+			}
+
+		//get intersection AB lock 
+		lock_acquire(intersection_AB_Lock); 
+
+		//enter intersection AB
+		enter(vehiclenumber, 0); 
+
+		
+		//remvoe vehicle from route A queue and free 
+		if (head_A->vehicle == vehiclenumber) {
+			struct Node *temp = head_A;
+			head_A = temp->next;
+			kfree(temp);
+		}
+		
+		//leave intersection AB
+		leave(vehiclenumber, 0); 
+		//release AB lock 
+		lock_release(intersection_AB_Lock);
+		
+	}
+
+	//if route is B
+	else if (route == 1){
+		//if no vehicles in queue, return 
+		if (head_B == NULL) {
+    		return; // Exit early if no vehicle exists
+		}
+
+		//get intersection BC lock 
+		lock_acquire(intersection_BC_Lock); 
+		//enter intersection BC
+		enter(vehiclenumber, 1); 
+		
+		//remove vehicle from head of route B queue and free 
+		if (head_B->vehicle == vehiclenumber){
+			struct Node *temp = head_B;
+			head_B = temp->next;
+			kfree(temp);
+		}
+		
+		//leave intersection BC 
+		leave(vehiclenumber, 1); 
+		//release BC lock 
+		lock_release(intersection_BC_Lock);
+		
+	}
+
+	//if route is C
+	else{
+		//if no vehicles in route C list, return  
+		if (head_C == NULL) {
+			return; // Exit early if no vehicle exists
+		}
+
+		//get intersection CA lock 
+		lock_acquire(intersection_CA_Lock); 
+		//enter intersection 
+		enter(vehiclenumber, 2); 
+		
+		//remove vehicle from head of route C queue 
+		if (head_C->vehicle == vehiclenumber){
+			struct Node *temp = head_C;
+			head_C = temp->next;
+			kfree(temp);
+		}
+		
+		//leave interesection CA 
+		leave(vehiclenumber, 2); 
+		//release CA lock 
+		lock_release(intersection_CA_Lock);
+		
+	}
+
 }
 
 
@@ -112,8 +329,459 @@ vehicle_thread(void * unusedpointer,
 	(void) unusedpointer;
 	(void) vehiclenumber;
 
-	(void) turn_left;
-	(void) turn_right;
+	//get route and type
+	int route = get_vehicle_route(vehiclenumber); 
+	int type = get_vehicle_type(vehiclenumber); 
+
+	//make node for new vehicle 
+	struct Node *newVehicle = kmalloc(sizeof(struct Node));
+	if (newVehicle == NULL){
+		panic("kmalloc failed"); 
+	}
+	newVehicle->vehicle = vehiclenumber; 
+	newVehicle->next = NULL; 
+	
+	//Add vehicle to appropriate Route LL 
+	if (route == 0){ //if route is A 
+		//call approach for this vehicle
+	
+		//lock route A LL
+		lock_acquire(routeA_LL_Lock); 
+		
+		if (head_A == NULL){ //check if head is null 
+				//set this vehicle as head 
+				head_A = newVehicle; 
+			}
+		
+		else{
+			//initialize curr and prev 
+			struct Node *curr = head_A; 
+			struct Node *prev = NULL;
+
+			if (type == 1){ //if a car 
+				
+			//iterate through LL and add car
+			while (curr != NULL &&  get_vehicle_type(curr->vehicle) != 0){
+					prev = curr; 
+					curr = curr->next; 
+			}
+				if (prev == NULL) {
+                // No trucks found; insert at the head
+                newVehicle->next = head_A; 
+                head_A = newVehicle; 
+            } else {
+                // Insert right before the first truck
+                newVehicle->next = curr; 
+                prev->next = newVehicle; 
+            }
+			}
+
+			else if (type == 0){ //if a truck 
+
+				//iterate through LL and add truck
+
+				while (curr != NULL){
+					prev = curr; 
+					curr = curr->next; 
+				}
+
+				//now prev is last node
+
+				//add to end of list  
+				prev->next = newVehicle; 
+
+			}
+		}
+		
+		//release lock 
+		//approach(vehiclenumber); 
+		lock_release(routeA_LL_Lock);
+		
+
+	}
+
+	else if (route == 1){ //if route is B
+
+		//lock route B LL
+		lock_acquire(routeB_LL_Lock); 
+		if (head_B == NULL){ //check if head is null 
+				//set this vehicle as head 
+				head_B = newVehicle; 
+			}
+		
+		else{
+			//initialize curr and prev 
+			struct Node *curr = head_B; 
+			struct Node *prev = NULL;
+
+			if (type == 1){ //if a car 
+				
+			//iterate through LL and add car
+			
+					while (curr != NULL &&  get_vehicle_type(curr->vehicle) != 0){
+					prev = curr; 
+					curr = curr->next; 
+			}
+				if (prev == NULL) {
+                // No trucks found; insert at the head
+                newVehicle->next = head_B; 
+                head_B= newVehicle; 
+            } else {
+                // Insert right before the first truck
+                newVehicle->next = curr; 
+                prev->next = newVehicle; 
+            }
+			}
+
+			else if (type == 0){ //if a truck 
+
+				//iterate through LL and add truck
+
+				while (curr != NULL){
+					prev = curr; 
+					curr = curr->next; 
+				}
+
+				//now prev is last node
+				//add to end of list  
+				prev->next = newVehicle; 
+
+			}
+		}
+
+		//release lock 
+		 	//approach(vehiclenumber); 
+		lock_release(routeB_LL_Lock);
+
+	}
+
+	else { //if route is C
+
+		//lock route C LL
+		lock_acquire(routeC_LL_Lock); 
+		if (head_C == NULL){ //check if head is null 
+				//set this vehicle as head 
+				head_C = newVehicle; 
+			}
+		
+		else{
+			
+			//initialize curr and prev 
+			struct Node *curr = head_C; 
+			struct Node *prev = NULL;
+
+			if (type == 1){ //if a car 
+				
+			//iterate through LL and add car
+			
+					while (curr != NULL &&  get_vehicle_type(curr->vehicle) != 0){
+					prev = curr; 
+					curr = curr->next; 
+			}
+				if (prev == NULL) {
+                // No trucks found; insert at the head
+                newVehicle->next = head_C; 
+                head_C = newVehicle; 
+            } else {
+                // Insert right before the first truck
+                newVehicle->next = curr; 
+                prev->next = newVehicle; 
+            }
+			}
+
+			else if (type == 0){ //if a truck 
+
+				//iterate through LL and add truck
+
+				while (curr != NULL){
+					prev = curr; 
+					curr = curr->next; 
+				}
+
+				//now prev is last node
+
+				//add to end of list  
+				prev->next = newVehicle; 
+
+			}
+		}
+		//approach(vehiclenumber); 
+		//release lock 
+		lock_release(routeC_LL_Lock);
+
+	}
+
+	approach(vehiclenumber); 
+	
+	//get turn direction 
+	int turn_direction = get_vehicle_turn_direction(vehiclenumber);
+
+		if(route == 0){
+			
+			//get route A priority queue lock 
+			
+			lock_acquire(routeA_LL_Lock);
+			
+			
+			//check if this vehicle is the next one in the queue 
+			if (head_A != NULL && vehiclenumber != head_A->vehicle){
+				//if not next...
+			
+				//get sleeping queue lock 
+				
+				lock_acquire(sleep_A_lock); 
+				//add thread to sleep queue 
+				enqueue(&sleep_head_A, newVehicle->vehicle); 
+				//release sleeping queue lock  
+				
+				lock_release(sleep_A_lock); 
+				
+				lock_release(routeA_LL_Lock); 
+
+				//sleep thread 
+				int spl = splhigh(); 
+				
+				
+				thread_sleep(newVehicle); 
+				splx(spl); 
+
+				//get sleeping queue lock 
+				
+				lock_acquire(sleep_A_lock);
+				 
+				//dequeue thread from sleep queue 
+				dequeue(newVehicle->vehicle, &sleep_head_A);  
+				//release lock 
+
+				
+				lock_release(sleep_A_lock); 
+				
+				lock_acquire(routeA_LL_Lock);
+				
+
+				 
+			}
+
+			//if vehicle is next, turn 
+			if(vehiclenumber ==  head_A->vehicle){
+			
+				//turn left 
+				if (turn_direction == 1){
+				turn_left(vehiclenumber); 
+
+				}
+
+			//otherwise turn right 
+			else{
+				turn_right(vehiclenumber); 
+			}
+			
+		}
+		 
+		//release priority queue lock 
+		
+		
+		
+		//wake next thread 
+		//if head_A thread is sleeping, wake it 
+		if (sleep_head_A != NULL && head_A != NULL){
+			int spl = splhigh();
+			lock_acquire(sleep_A_lock); 
+			thread_wakeup(head_A);
+			splx(spl);
+
+			lock_release(sleep_A_lock); 
+
+		
+			
+		}
+		lock_release(routeA_LL_Lock);
+		
+
+		
+		}
+
+		else if(route == 1){
+
+						//get route A priority queue lock 
+			
+			lock_acquire(routeB_LL_Lock);
+			
+			
+			//check if this vehicle is the next one in the queue 
+			if (head_B != NULL && vehiclenumber != head_B->vehicle){
+				//if not next...
+			
+				//get sleeping queue lock 
+				
+				lock_acquire(sleep_B_lock); 
+				//add thread to sleep queue 
+				enqueue(&sleep_head_B, newVehicle->vehicle); 
+				//release sleeping queue lock  
+				
+				lock_release(sleep_B_lock); 
+				
+				lock_release(routeB_LL_Lock); 
+
+				//sleep thread 
+				int spl = splhigh(); 
+				
+				
+				thread_sleep(newVehicle); 
+				splx(spl); 
+
+				//get sleeping queue lock 
+				
+				lock_acquire(sleep_B_lock);
+				 
+				//dequeue thread from sleep queue 
+				dequeue(newVehicle->vehicle, &sleep_head_B);  
+				//release lock 
+
+				
+				lock_release(sleep_B_lock); 
+				
+				lock_acquire(routeB_LL_Lock);
+				
+
+				 
+			}
+
+			//if vehicle is next, turn 
+			if(vehiclenumber ==  head_B->vehicle){
+			
+				//turn left 
+				if (turn_direction == 1){
+				turn_left(vehiclenumber); 
+
+				}
+
+			//otherwise turn right 
+			else{
+				turn_right(vehiclenumber); 
+			}
+			
+		}
+		 
+		//release priority queue lock 
+		
+		
+		
+		//wake next thread 
+		//if head_A thread is sleeping, wake it 
+		if (sleep_head_B != NULL && head_B != NULL){
+			int spl = splhigh();
+			lock_acquire(sleep_B_lock); 
+			thread_wakeup(head_B);
+			splx(spl);
+
+
+			lock_release(sleep_B_lock); 
+
+		
+			
+		}
+		lock_release(routeB_LL_Lock);
+		
+
+		
+		}
+
+		else{
+						//get route A priority queue lock 
+			
+			lock_acquire(routeC_LL_Lock);
+			
+			
+			//check if this vehicle is the next one in the queue 
+			if (head_C != NULL && vehiclenumber != head_C->vehicle){
+				//if not next...
+			
+				//get sleeping queue lock 
+				
+				lock_acquire(sleep_C_lock); 
+				//add thread to sleep queue 
+				enqueue(&sleep_head_C, newVehicle->vehicle); 
+				//release sleeping queue lock  
+				
+				lock_release(sleep_C_lock); 
+				
+				lock_release(routeC_LL_Lock); 
+
+				//sleep thread 
+				int spl = splhigh(); 
+				
+				
+				thread_sleep(newVehicle); 
+				splx(spl); 
+
+				//get sleeping queue lock 
+				
+				lock_acquire(sleep_C_lock);
+				 
+				//dequeue thread from sleep queue 
+				dequeue(newVehicle->vehicle, &sleep_head_C);  
+				//release lock 
+
+				
+				lock_release(sleep_C_lock); 
+				
+				lock_acquire(routeC_LL_Lock);
+				
+
+				 
+			}
+
+			//if vehicle is next, turn 
+			if(vehiclenumber ==  head_C->vehicle){
+			
+				//turn left 
+				if (turn_direction == 1){
+				turn_left(vehiclenumber); 
+
+				}
+
+			//otherwise turn right 
+			else{
+				turn_right(vehiclenumber); 
+			}
+			
+		}
+		 
+		//release priority queue lock 
+		
+		
+		
+		//wake next thread 
+		//if head_A thread is sleeping, wake it 
+		if (sleep_head_C != NULL && head_C != NULL){
+			int spl = splhigh();
+			lock_acquire(sleep_C_lock); 
+			thread_wakeup(head_C);
+			splx(spl);
+
+
+			lock_release(sleep_C_lock); 
+
+		
+			
+		}
+		lock_release(routeC_LL_Lock);
+		
+
+		
+	}
+		
+		
+
+	lock_acquire(vehicle_count_lock);
+    vehicles_finished++;  // Increment the number of vehicles finished
+    lock_release(vehicle_count_lock);
+
+	
+
+	//(void) turn_left;
+	//(void) turn_right;
 
 	/* Note: Throughout this project you will use the get_vehicle_* functions
 	 * to get various information about the vehicle. For example:
@@ -127,6 +795,134 @@ vehicle_thread(void * unusedpointer,
 	 */
 }
 
+/*SLEEPING THREAD QUEUE FUNCTIONS*/
+/**
+ * enqueue() 
+ * 
+ * Arguments: 
+ * 			struct Node **sleep_head: double pointer for head of queue list 
+ * 			unsigned long int vehiclenumber: holds vehicle id number 
+ * 
+ * Returns: 
+ * 			nothing 
+ * 
+ * Notes: 
+ * 			Used to add a sleeping thread to the sleep queue that corresponds with that route. 
+ */
+void enqueue(struct Node **sleep_head, unsigned long int vehiclenumber){
+	//get vehicle type 
+	int type = get_vehicle_type(vehiclenumber); 
+
+	//if head of queue is NULL...
+	if (*sleep_head == NULL){ 
+				
+					//create new node that is the vehicle number and make head of the queue 
+					*sleep_head = kmalloc(sizeof(struct Node)); 
+					if (*sleep_head == NULL){
+						panic("kmalloc failed"); 
+				
+					}
+
+					//set fields 
+					(*sleep_head) ->vehicle = vehiclenumber; 
+					(*sleep_head) ->next = NULL; 
+				
+		
+			}
+		
+		//otherwise, add to queue 
+		else{
+			//create new node that is vehicle number 
+			struct Node *newNode = kmalloc(sizeof(struct Node)); 
+			if (newNode == NULL){
+				panic("kmalloc failed"); 
+			}
+			//set fields 
+			newNode->next = NULL; 
+			newNode -> vehicle = vehiclenumber;
+
+
+			//initialize curr and prev 
+			struct Node *curr = *sleep_head; 
+			struct Node *prev = NULL;
+
+			if (type == 1){ //if a car 
+				
+			//iterate through LL and add car
+			while (curr != NULL &&  get_vehicle_type(curr->vehicle) != 0){
+					prev = curr; 
+					curr = curr->next; 
+			}
+				//if no trucks present, insert at head of queue 
+				if (prev == NULL) {
+                newNode->next = *sleep_head;
+				*sleep_head = newNode; 
+			}
+				//otherwise there is at least one truck
+				//iterate to end of cars and insert before first truck 
+             else {
+                newNode->next = curr; 
+                prev->next = newNode; 
+            }
+			}
+
+			//if vehicle is a truck...
+			else if (type == 0){ 
+
+				//iterate through LL and add truck to end of queue 
+				while (curr != NULL){
+					prev = curr; 
+					curr = curr->next; 
+				}
+
+				prev->next = newNode; 
+
+			}
+		}
+
+	
+}
+
+
+/**
+ * dequeue() 
+ * 
+ * Arguments: 
+ * 			unsigned long int vehiclenumber: holds vehicle id number 			
+ * 			struct Node **sleep_head: double pointer for head of queue list 
+ * 			
+ * Returns: 
+ * 			nothing 
+ * 
+ * Notes: 
+ * 			Used to remove a sleeping thread from the sleep queue that corresponds with that route. 
+ */
+void dequeue(unsigned long int vehiclenumber, struct Node **sleep_head){
+
+	//head of queue 
+	struct Node *curr = *sleep_head; 
+
+	//if head is null, return 
+	if (curr == NULL){
+		return; 
+	}
+
+	//remove vehicle from head of queue and free 
+	if (curr->vehicle == vehiclenumber){
+		*sleep_head = curr->next; 
+		kfree(curr); 
+		return; 
+	}
+	
+
+	
+	
+	
+
+
+}
+
+
 
 /*
  * stoplight_driver()
@@ -148,11 +944,27 @@ vehicle_thread(void * unusedpointer,
  *      to finish().
  */
 
-int
-stoplight_driver(int vehicle_count)
-{
-	int index, error;
+int stoplight_driver(int vehicle_count) {
+    int index, error;
+
+    // Initialize intersection, route, and sleeping queue locks
+    intersection_AB_Lock = lock_create("intersection_AB_Lock");
+    intersection_BC_Lock = lock_create("intersection_BC_Lock");
+    intersection_CA_Lock = lock_create("intersection_CA_Lock");
+
+    routeA_LL_Lock = lock_create("routeA_LL_Lock");
+    routeB_LL_Lock = lock_create("routeB_LL_Lock");
+    routeC_LL_Lock = lock_create("routeC_LL_Lock");
+
+	sleep_A_lock = lock_create("sleep_A_lock");
+	sleep_B_lock = lock_create("sleep_B_lock");
+	sleep_C_lock = lock_create("sleep_B_lock");
+
+	//initialize vehicle count lock 
+	vehicle_count_lock = lock_create("vehicle_count_lock");
+
 
+	//create vehicle threads 
 	for (index = 0; index < vehicle_count; index++) {
 
 		/* This creates a thread for each vehicle, with unique numbers. */
@@ -186,7 +998,31 @@ stoplight_driver(int vehicle_count)
 	 * Note that deleting the call to finish() will not score you any points. You
 	 * must correctly synchronize it to get credit for that part of the project.
 	 */
-	finish();
+	
+		//wait until all vehicles have finished 
+        while (vehicles_finished != vehicle_count) { //not done 
+			continue; 
+        }  
+
+		//call finish once all vehicles are done 
+		finish(); 
+	
+		//clean up 
+		lock_destroy(vehicle_count_lock);
+
+		lock_destroy(intersection_AB_Lock);
+		lock_destroy(intersection_BC_Lock);
+		lock_destroy(intersection_CA_Lock);
+		
+		lock_destroy(routeA_LL_Lock); 
+		lock_destroy(routeB_LL_Lock); 
+		lock_destroy(routeC_LL_Lock); 
+
+		lock_destroy(sleep_A_lock); 
+		lock_destroy(sleep_B_lock); 
+		lock_destroy(sleep_C_lock); 
 
 	return 0;
+
 }
+
diff --git a/kern/asst1/stoplight_framework.c b/kern/asst1/stoplight_framework.c
index 54f320a..b91c89f 100644
--- a/kern/asst1/stoplight_framework.c
+++ b/kern/asst1/stoplight_framework.c
@@ -319,28 +319,97 @@ stoplight_custom(int nargs, char **args) {
 	switch(num) {
 		/* Feel free to add your own custom stoplight tests here! */
 
-		case 0:
+		case 0: //all cars, route A, left turn
 			setup(30);
+			int i; 
 
-			/* Add vehicle setup here */
+			for (i= 0; i < 30; i++){
+				all_vehicles[i].route = ROUTE_A;
+				all_vehicles[i].type = VEHICLE_CAR; 
+				all_vehicles[i].turn_direction = TURN_LEFT; 
+			}
 
 			stoplight_driver(30);
 			break;
 
-		case 1:
+		case 1: //cars and trucks, route A, left turn
 			setup(30);
+			
+			for(i = 0; i < 30; ++i) {
+				/* Important: All vehicles on same route, so we can test priority. */
+				all_vehicles[i].route = ROUTE_A;
+				all_vehicles[i].turn_direction = TURN_LEFT;
 
-			/* Add vehicle setup here */
+				/* First 15 low priority, next 15 high priority. */
+				all_vehicles[i].type = (i >= 15 ? VEHICLE_CAR : VEHICLE_TRUCK);
+			}
+
+
+			stoplight_driver(30);
+			break;
+
+
+		case 2: 
+			setup(30); //route C,, all left turn
+
+			for(i = 0; i < 30; ++i) {
+				all_vehicles[i].route = ROUTE_C;
+				all_vehicles[i].turn_direction = TURN_LEFT;
+				
+				
+				/* First 15 low priority, next 15 high priority. */
+				all_vehicles[i].type = (i >= 15 ? VEHICLE_CAR : VEHICLE_TRUCK);
+			}
 
 			stoplight_driver(30);
 			break;
 
+		
+		case 3: 
+			setup(100); //all routes, all left turn
+
+			for(i = 0; i < 100; ++i) {
+				all_vehicles[i].route = random() % 3;
+				all_vehicles[i].turn_direction = TURN_LEFT;
+				
+				
+				/* First 15 low priority, next 15 high priority. */
+				all_vehicles[i].type = (i >= 15 ? VEHICLE_CAR : VEHICLE_TRUCK);
+			}
+
+			stoplight_driver(100);
+			break;
+
+		case 4: 
+			setup(3); //one car on each route, all turning left 
+
+			all_vehicles[0].route = ROUTE_A; 
+			all_vehicles[0].turn_direction = TURN_LEFT;
+			all_vehicles[0].type = VEHICLE_CAR;
+
+			all_vehicles[1].route = ROUTE_B; 
+			all_vehicles[1].turn_direction = TURN_LEFT;
+			all_vehicles[1].type = VEHICLE_CAR;
+
+			all_vehicles[2].route = ROUTE_C; 
+			all_vehicles[2].turn_direction = TURN_LEFT;
+			all_vehicles[2].type = VEHICLE_CAR;
+
+		
+			stoplight_driver(3);
+			break;
+
+	
+			
+
 		/* Add more tests if you want here */
 
 		default:
 			kprintf("Unknown sl_custom test %d\n", num);
 			break;
-	}
+	
 
-	return 0;
+	
+}
+return 0;
 }
\ No newline at end of file
diff --git a/kern/include/synch.h b/kern/include/synch.h
index af890e4..7223b72 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -51,6 +51,7 @@ void              sem_destroy(struct semaphore *);
 struct lock {
 	char *name;
 	struct thread * volatile current_holder;
+	int flag;
 	// add what you need here
 	// (don't forget to mark things volatile as needed)
 };
diff --git a/kern/include/synch_blank.h b/kern/include/synch_blank.h
index 3583e78..c195642 100644
--- a/kern/include/synch_blank.h
+++ b/kern/include/synch_blank.h
@@ -50,6 +50,7 @@ void              sem_destroy(struct semaphore *);
 
 struct lock {
 	char *name;
+	int flag; //checking if the lock is acquired or available 
 	// add what you need here
 	// (don't forget to mark things volatile as needed)
 };
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 817928e..ab62d34 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -120,47 +120,101 @@ lock_create(const char *name)
 	DEBUG(DB_VM, "Lock created: %s\n", lock->name); 
 	
 	// add stuff here as needed
-	
+	lock->flag = 1; 
+
+
 	return lock;
 }
 
 void
 lock_destroy(struct lock *lock)
 {
+	
 	assert(lock != NULL);
 
 	// add stuff here as needed
 	
+	int spl; 
+	spl = splhigh(); //no interruptions 
+	
+	assert(thread_hassleepers(lock) == 0); //check that there are not threads waiting on the lock
+
+	
+
+	
 	DEBUG(DB_VM, "Lock %s destroyed.\n", lock->name); 
 
 	kfree(lock->name);
+	kfree(lock->current_holder); 
+	//kfree(lock->flag); 
 	kfree(lock);
+
+	splx(spl); //restore spl to previous level 
 }
 
 void
 lock_acquire(struct lock *lock)
 {
-	// Write this
+	int spl;
+	assert(lock != NULL);
 
-	(void)lock;  // suppress warning until code gets written
+	/*
+	 * May not block in an interrupt handler.
+	 *
+	 * For robustness, always check, even if we can actually
+	 * complete the P without blocking.
+	 */
+	assert(in_interrupt==0);
+
+	spl = splhigh(); //diable interrupts 
+	while (lock->flag==0) { //if lock flag is 0, lock not available, sleep thread 
+		thread_sleep(lock);
+	}
+	assert(lock->flag == 1); //lock is available, make sure flag is 1 
+	lock->flag = 0; //set flag to 0 (lock is being used)
+	lock->current_holder = curthread; //set self to current_holder
+	splx(spl); //reset spl level 
+
+	//(void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
 	// Write this
+	
+	int spl; 
+	
+	//check that lock given is not null
+	assert(lock != NULL); 
+	
+	spl = splhigh(); //disable interrupts 
 
-	(void)lock;  // suppress warning until code gets written
+	//decrease lock value 
+	lock->flag = 1; 
+	lock -> current_holder = NULL;
+
+	//wake up next thread
+	thread_wakeup(lock); 
+
+
+
+	//set spl to previous level (enable interrupts) 
+	splx(spl);
+
+
+	//(void)lock;  // suppress warning until code gets written
 }
 
 int
 lock_do_i_hold(struct lock *lock)
 {
 	// Write this
+	if(lock->current_holder == curthread) return 1;
+	else return 0;
+	//(void)lock;  // suppress warning until code gets written
 
-	(void)lock;  // suppress warning until code gets written
-
-	return 1;    // dummy until code gets written
+	//return 1;    // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
diff --git a/sys161-default.conf b/sys161-default.conf
index 930fb69..221a52e 100644
--- a/sys161-default.conf
+++ b/sys161-default.conf
@@ -120,4 +120,5 @@
 30	trace
 # Note: Maximum possible ram is 16 megabytes (16777216).
 # 2097152 = 2 megabytes.
-31	busctl	ramsize=2097152
+31	#busctl	ramsize=2097152
+	busctl ramsize = 8388608
